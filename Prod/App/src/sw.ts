/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate, CacheFirst } from "workbox-strategies";
import { ExpirationPlugin } from "workbox-expiration";
import { CacheableResponsePlugin } from "workbox-cacheable-response";

declare let self: ServiceWorkerGlobalScope;

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Runtime caching strategies

// Cache Supabase API responses (stale-while-revalidate)
registerRoute(
  /^https:\/\/.*\.supabase\.co\/rest\/v1\/.*/i,
  new StaleWhileRevalidate({
    cacheName: "supabase-api-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache images (cache-first)
registerRoute(
  /\.(?:png|jpg|jpeg|svg|gif|webp)$/i,
  new CacheFirst({
    cacheName: "image-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache fonts (cache-first)
registerRoute(
  /\.(?:woff|woff2|ttf|otf)$/i,
  new CacheFirst({
    cacheName: "font-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Cache Supabase storage (avatars, etc)
registerRoute(
  /^https:\/\/.*\.supabase\.co\/storage\/v1\/.*/i,
  new CacheFirst({
    cacheName: "supabase-storage-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  })
);

// ============================================
// Push Notification Handlers
// ============================================

interface NotificationData {
  type?: string;
  period?: string;
  habitCount?: number;
  habitIds?: string[];
  url?: string;
}

/**
 * Handle incoming push notifications
 */
self.addEventListener("push", (event) => {
  if (!event.data) {
    console.log("[SW] Push received but no data");
    return;
  }

  try {
    const payload = event.data.json();
    console.log("[SW] Push received:", payload);

    const options: NotificationOptions = {
      body: payload.body || "Você tem hábitos pendentes!",
      icon: payload.icon || "/icons/icon-192.png",
      badge: payload.badge || "/icons/badge-72.png",
      tag: payload.tag || "bora-notification",
      data: payload.data || {},
      actions: payload.actions || [
        { action: "open", title: "Ver hábitos" },
        { action: "dismiss", title: "Depois" },
      ],
      requireInteraction: false,
      silent: false,
    };

    event.waitUntil(
      self.registration.showNotification(payload.title || "Bora Hábitos", options)
    );
  } catch (error) {
    console.error("[SW] Error processing push:", error);
  }
});

/**
 * Handle notification click events
 */
self.addEventListener("notificationclick", (event) => {
  console.log("[SW] Notification clicked:", event.action);

  event.notification.close();

  const action = event.action;
  const data = event.notification.data as NotificationData || {};

  // If user clicked "dismiss", just close
  if (action === "dismiss") {
    return;
  }

  // Determine target URL
  const targetUrl = data.url || "/app/dashboard";
  const fullUrl = new URL(targetUrl, self.location.origin).href;

  // Try to focus existing window or open new one
  event.waitUntil(
    self.clients
      .matchAll({ type: "window", includeUncontrolled: true })
      .then((windowClients) => {
        // Look for an existing window to focus
        for (const client of windowClients) {
          if (client.url.includes(self.location.origin) && "focus" in client) {
            // Found an existing window, focus it and navigate
            return client.focus().then(() => {
              // Send message to app to navigate to the target URL
              client.postMessage({
                type: "NOTIFICATION_CLICK",
                url: targetUrl,
                data: data,
              });
              return client;
            });
          }
        }

        // No existing window found, open a new one
        if (self.clients.openWindow) {
          return self.clients.openWindow(fullUrl);
        }
      })
      .catch((error) => {
        console.error("[SW] Error handling notification click:", error);
      })
  );
});

/**
 * Handle notification close events
 */
self.addEventListener("notificationclose", (event) => {
  console.log("[SW] Notification closed:", event.notification.tag);
});

// ============================================
// Service Worker Lifecycle
// ============================================

/**
 * Skip waiting and activate immediately
 */
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

/**
 * Claim all clients when activating
 */
self.addEventListener("activate", (event) => {
  event.waitUntil(self.clients.claim());
});

console.log("[SW] Service Worker loaded - Bora Hábitos v1.0");
