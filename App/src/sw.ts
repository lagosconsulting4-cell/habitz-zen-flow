/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate, CacheFirst } from "workbox-strategies";
import { ExpirationPlugin } from "workbox-expiration";
import { CacheableResponsePlugin } from "workbox-cacheable-response";

declare let self: ServiceWorkerGlobalScope;

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Runtime caching strategies

// Cache Supabase API responses (stale-while-revalidate)
// Note: StaleWhileRevalidate returns cache instantly and updates in background,
// so networkTimeout is not needed - no waiting for network, preventing hangs.
// This provides better UX than NetworkFirst with timeout (which would wait).
registerRoute(
  /^https:\/\/.*\.supabase\.co\/rest\/v1\/.*/i,
  new StaleWhileRevalidate({
    cacheName: "supabase-api-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache images (cache-first)
registerRoute(
  /\.(?:png|jpg|jpeg|svg|gif|webp)$/i,
  new CacheFirst({
    cacheName: "image-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache fonts (cache-first)
registerRoute(
  /\.(?:woff|woff2|ttf|otf)$/i,
  new CacheFirst({
    cacheName: "font-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Cache Supabase storage (avatars, etc)
registerRoute(
  /^https:\/\/.*\.supabase\.co\/storage\/v1\/.*/i,
  new CacheFirst({
    cacheName: "supabase-storage-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  })
);

// ============================================
// Push Notification Handlers
// ============================================

interface NotificationData {
  type?: string;
  period?: string;
  habitCount?: number;
  habitIds?: string[];
  url?: string;
}

/**
 * Handle incoming push notifications
 */
self.addEventListener("push", (event) => {
  if (!event.data) {
    console.log("[SW] Push received but no data");
    return;
  }

  try {
    const payload = event.data.json();
    console.log("[SW] Push received:", payload);

    const options: NotificationOptions = {
      body: payload.body || "Você tem hábitos pendentes!",
      icon: payload.icon || "/icons/icon-192.png",
      badge: payload.badge || "/icons/badge-72.png",
      tag: payload.tag || "bora-notification",
      data: payload.data || {},
      actions: payload.actions || [
        { action: "open", title: "Ver hábitos" },
        { action: "dismiss", title: "Depois" },
      ],
      requireInteraction: false,
      silent: false,
    };

    event.waitUntil(
      self.registration.showNotification(payload.title || "Bora Hábitos", options)
    );
  } catch (error) {
    console.error("[SW] Error processing push:", error);
  }
});

/**
 * Handle notification click events
 */
self.addEventListener("notificationclick", (event) => {
  console.log("[SW] Notification clicked:", event.action);

  event.notification.close();

  const action = event.action;
  const data = event.notification.data as NotificationData || {};

  // If user clicked "dismiss", just close
  if (action === "dismiss") {
    return;
  }

  // If user clicked "complete", send message to app without opening
  if (action === "complete" && data.habitId) {
    event.waitUntil(
      self.clients
        .matchAll({ type: "window", includeUncontrolled: true })
        .then((windowClients) => {
          // Send message to app to complete the habit
          for (const client of windowClients) {
            if (client.url.includes(self.location.origin)) {
              client.postMessage({
                type: "COMPLETE_HABIT_FROM_NOTIFICATION",
                habitId: data.habitId,
              });
              return;
            }
          }
        })
        .catch((error) => {
          console.error("[SW] Error completing habit from notification:", error);
        })
    );
    return;
  }

  // Determine target URL
  const targetUrl = data.url || "/app/dashboard";
  const fullUrl = new URL(targetUrl, self.location.origin).href;

  // Try to focus existing window or open new one
  event.waitUntil(
    self.clients
      .matchAll({ type: "window", includeUncontrolled: true })
      .then((windowClients) => {
        // Look for an existing window to focus
        for (const client of windowClients) {
          if (client.url.includes(self.location.origin) && "focus" in client) {
            // Found an existing window, focus it and navigate
            return client.focus().then(() => {
              // Send message to app to navigate to the target URL
              client.postMessage({
                type: "NOTIFICATION_CLICK",
                url: targetUrl,
                data: data,
              });
              return client;
            });
          }
        }

        // No existing window found, open a new one
        if (self.clients.openWindow) {
          return self.clients.openWindow(fullUrl);
        }
      })
      .catch((error) => {
        console.error("[SW] Error handling notification click:", error);
      })
  );
});

/**
 * Handle notification close events
 */
self.addEventListener("notificationclose", (event) => {
  console.log("[SW] Notification closed:", event.notification.tag);
});

// ============================================
// Background Sync API
// ============================================

/**
 * Background Sync - processa fila offline mesmo com app fechado
 * Complementa o useOfflineSync do app layer
 */
self.addEventListener("sync", (event) => {
  console.log("[SW] Background sync event:", event.tag);

  if (event.tag === "sync-offline-queue") {
    event.waitUntil(syncOfflineQueue());
  }
});

/**
 * Processa a fila de operações offline do IndexedDB
 */
async function syncOfflineQueue(): Promise<void> {
  try {
    console.log("[SW] Starting background sync...");

    // Abrir IndexedDB para acessar a fila
    const db = await openOfflineDB();
    const queue = await getQueueFromDB(db);

    if (queue.length === 0) {
      console.log("[SW] Sync queue is empty");
      return;
    }

    console.log(`[SW] Processing ${queue.length} queued items`);
    let successCount = 0;

    for (const item of queue) {
      try {
        // Tentar processar o item
        await processQueueItemInSW(item);
        await removeFromDB(db, item.id);
        successCount++;
      } catch (error) {
        console.error("[SW] Failed to sync item:", item.id, error);
        // Incrementar retries no IndexedDB
        await incrementRetriesInDB(db, item.id);
      }
    }

    console.log(`[SW] Sync completed: ${successCount}/${queue.length} items`);

    // Notificar app se estiver aberto
    const clients = await self.clients.matchAll();
    clients.forEach((client) => {
      client.postMessage({
        type: "SYNC_COMPLETED",
        count: successCount,
      });
    });
  } catch (error) {
    console.error("[SW] Background sync error:", error);
  }
}

/**
 * Abre o banco IndexedDB offline
 */
function openOfflineDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("bora-offline", 1);
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

/**
 * Busca items da fila no IndexedDB
 */
async function getQueueFromDB(db: IDBDatabase): Promise<any[]> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(["syncQueue"], "readonly");
    const store = transaction.objectStore("syncQueue");
    const request = store.getAll();

    request.onsuccess = () => resolve(request.result || []);
    request.onerror = () => reject(request.error);
  });
}

/**
 * Remove item da fila no IndexedDB
 */
async function removeFromDB(db: IDBDatabase, id: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(["syncQueue"], "readwrite");
    const store = transaction.objectStore("syncQueue");
    const request = store.delete(id);

    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

/**
 * Incrementa retries no IndexedDB
 */
async function incrementRetriesInDB(db: IDBDatabase, id: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(["syncQueue"], "readwrite");
    const store = transaction.objectStore("syncQueue");
    const getRequest = store.get(id);

    getRequest.onsuccess = () => {
      const item = getRequest.result;
      if (item) {
        item.retries = (item.retries || 0) + 1;
        const putRequest = store.put(item);
        putRequest.onsuccess = () => resolve();
        putRequest.onerror = () => reject(putRequest.error);
      } else {
        resolve();
      }
    };
    getRequest.onerror = () => reject(getRequest.error);
  });
}

/**
 * Processa um item da fila (similar ao useOfflineSync)
 */
async function processQueueItemInSW(item: any): Promise<void> {
  // Nota: Service Worker não tem acesso ao supabase client
  // Então fazemos requests HTTP diretos para a API
  const supabaseUrl = "https://jbucnphyrziaxupdsnbn.supabase.co";
  const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Impic2NucGh5cnppYXh1cGRzYmJuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzMxMzI3NzQsImV4cCI6MjA0ODcwODc3NH0.wHUpGNb_pOPBGGfEPx3bWCwJ3JEV5w5PSRlUfKPxfUQ";

  const headers = {
    "Content-Type": "application/json",
    "apikey": supabaseKey,
    "Authorization": `Bearer ${supabaseKey}`,
  };

  switch (item.type) {
    case "create_habit":
    case "create_completion":
      const table = item.type === "create_habit" ? "habits" : "habit_completions";
      const response = await fetch(`${supabaseUrl}/rest/v1/${table}`, {
        method: "POST",
        headers,
        body: JSON.stringify(item.payload),
      });

      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      break;

    case "update_habit":
      const { id, ...updates } = item.payload;
      const updateResponse = await fetch(`${supabaseUrl}/rest/v1/habits?id=eq.${id}`, {
        method: "PATCH",
        headers,
        body: JSON.stringify(updates),
      });

      if (!updateResponse.ok) throw new Error(`HTTP ${updateResponse.status}`);
      break;

    case "delete_habit":
    case "delete_completion":
      const deleteTable = item.type === "delete_habit" ? "habits" : "habit_completions";
      const deleteResponse = await fetch(
        `${supabaseUrl}/rest/v1/${deleteTable}?id=eq.${item.payload.id}`,
        {
          method: "DELETE",
          headers,
        }
      );

      if (!deleteResponse.ok) throw new Error(`HTTP ${deleteResponse.status}`);
      break;

    default:
      throw new Error(`Unknown sync type: ${item.type}`);
  }
}

// ============================================
// Service Worker Lifecycle
// ============================================

/**
 * Skip waiting and activate immediately
 */
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

/**
 * Claim all clients when activating
 */
self.addEventListener("activate", (event) => {
  event.waitUntil(self.clients.claim());
});

console.log("[SW] Service Worker loaded - Bora Hábitos v1.0");
